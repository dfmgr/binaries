#!/usr/bin/env bash

APPNAME="$(basename $0)"
USER="${SUDO_USER:-${USER}}"

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
##@Version     : 010920210727-git
# @Author      : Jason
# @Contact     : casjaysdev@casjay.net
# @File        : mpd-notify
# @Created     : Wed, Aug 05, 2020, 02:00 EST
# @License     : WTFPL
# @Copyright   : Copyright (c) CasjaysDev
# @Description : mpd notfication script
#
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Import functions
CASJAYSDEVDIR="${CASJAYSDEVDIR:-/usr/local/share/CasjaysDev/scripts}"
SCRIPTSFUNCTDIR="${CASJAYSDEVDIR:-/usr/local/share/CasjaysDev/scripts}/functions"
SCRIPTSFUNCTFILE="${SCRIPTSAPPFUNCTFILE:-testing.bash}"
SCRIPTSFUNCTURL="${SCRIPTSAPPFUNCTURL:-https://github.com/dfmgr/installer/raw/master/functions}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
if [ -f "$PWD/$SCRIPTSFUNCTFILE" ]; then
  . "$PWD/$SCRIPTSFUNCTFILE"
elif [ -f "$SCRIPTSFUNCTDIR/$SCRIPTSFUNCTFILE" ]; then
  . "$SCRIPTSFUNCTDIR/$SCRIPTSFUNCTFILE"
fi
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
user_install
__options "$@"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

__require_app mpd mpc

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

[ -d "$HOME/.config/mpd/mpd-notify" ] || printf_exit "1" "1" "Please install my mpd dotfiles | dfmgr install mpd"

daemonName="mpd-notify"
APP="$HOME/.config/mpd/mpd-notify"
CONFIG="$APP/mpd-notify.cfg"
MPDSERVER="${MPDSERVER:-localhost}"
MPDSERVER_PORT=${MPDSERVER_PORT:-6600}
NOTIFYSONG=true
STATUSNOTIF=true
pidFile="$APP/$daemonName.pid"
logFile="$APP/$daemonName.log"
runInterval=1
logMaxSize="100"

if [ -f "$APP/mpd-notify.cfg" ]; then
  source "$APP/mpd-notify.cfg"
fi

myPid="$(echo $$)"

log() { echo "$1" >>"$logFile"; }
__mpc() { mpc -h "$MPDSERVER" -p "$MPDSERVER_PORT" "$@" && return 0 || return 1; }

getFile() {
  file="$(__mpc -f %file% | head -n 1)"
  albumPath="$(echo "$file" | sed 's/$(basename "$file")//')"
  __mpc -f %file% | head -n 1
}

getArtAlb() {
  __mpc -f "%artist% - %album%" | head -n 1
}

scrapeDiscogs() {
  artAlb=$(getArtAlb)
  log "$(python3 "$APP""/cogsCover.py" "$artAlb" "$DISCOGSKEY" "$DISCOGSSECRET")"
  # cogsCover downloads to ${TMP:-/tmp}/image....
  __cp_rf ${TMP:-/tmp}/image.jpg "$coverPath" >/dev/null 2>&1
  __rm_rf ${TMP:-/tmp}/image.jpg >/dev/null 2>&1
}

notifyStatus() {
  # Compare old and new status.
  if $STATUSNOTIF; then
    if [[ $curStatus != "$newStatus" ]]; then
      if [[ $newStatus -eq 0 ]]; then
        notifications "MPD" "Paused"
      else
        notifications "MPD" "Playing: $newTitleArtist"
      fi
    fi
  fi
}

findCover() {
  coverPath=
  maxFile=
  maxRes=
  for file in "$MUSFOLDER$albumPath"*; do
    if [[ "$file" == *".jpg" ]] || [[ "$file" == *".jpeg" ]] || [[ "$file" == *".png" ]]; then
      curRes=$(identify -format "%W" "$file")
      if [[ -z $maxFile ]]; then
        maxFile="$file"
        maxRes="$curRes"
      elif [[ $curRes -gt $maxRes ]]; then
        maxFile="$file"
        maxRes="$curRes"
      fi
    fi
  done

  coverPath="$maxFile"
  if [[ "$coverPath" == *".png" ]]; then
    newPath="$(echo $coverPath | sed 's/png/jpg/g')"
    convert "$coverPath" "$newPath"
    coverPath=$newPath
  fi

  if [[ -z "$coverPath" ]]; then
    coverPath=$MUSFOLDER$albumPath"cover.jpg"
    if $AUTOSCRAPE; then
      scrapeDiscogs
    fi
  fi
}

setWallpaper() {
  curRes=$(xdpyinfo | grep dimensions | grep -E -o "   .+x" | sed -r 's/x.+?$//' | sed -r 's/^.+[^0-9]//g')
  dimensions=$(xdpyinfo | grep dimensions | awk '{print $2}')
  if $WALLPAPER; then
    if [[ $maxRes -ge $curRes ]]; then
      feh --bg-scale "$coverPath" >/dev/null 2>&1
    else
      if $CENTERED; then
        if $COMMON; then
          commonColor="$(convert "$coverPath" -colors 2 -depth 8 -unique-colors -format "%c" histogram:info: | grep -Eo "#.{6}" | tail -n 1)"
          convert "$coverPath" -gravity center -background "$commonColor" -extent $dimensions "${TMP:-/tmp}/cover.jpg"
          feh --bg-center "${TMP:-/tmp}/cover.jpg" >/dev/null 2>&1
        else
          convert "$coverPath" -gravity center -background "#$MATCOLOR" -extent $dimensions "${TMP:-/tmp}/cover.jpg"
          feh --bg-center "${TMP:-/tmp}/cover.jpg" >/dev/null 2>&1
        fi
      else
        feh --bg-tile "$coverPath" >/dev/null 2>&1
      fi
    fi
  fi
}

notifySong() {
  # Compare old and new songs.
  if [[ $currTitleArtist != "$newTitleArtist" ]]; then
    findCover
    if [[ -e $coverPath ]]; then # If there's a cover...
      setWallpaper
    fi
    if $NOTIFYSONG; then
      notifications "MPD" "$newTitleArtist"
    fi
  fi
}

notifyVolume() {
  if [[ $curVol != "$newVol" ]]; then
    notifications "MPD" "$newVol"
  fi
}
#############
setupDaemon() {
  if [ ! -f "$logFile" ]; then
    touch "$logFile"
  else
    # Check to see if we need to rotate the logs.
    size=$(($(ls -l "$logFile" | cut -d " " -f 5) / 1024))
    if [[ "$size" -gt "$logMaxSize" ]]; then
      __rm_rf "$logFile"
      touch "$logFile"
    fi
  fi
  __devnull __mpc
  if [[ $? -ne 0 ]]; then
    printf_info "MPD not running. Attempting to start..."
    __start mpd
    if [[ $? -ne 0 ]]; then
      printf_exit "Unable to start MPD. Please do it yourself then start mpd-notify."
    else
      printf_green "Everything is good!"
    fi
  fi
  __running mpd || printf_exit "1" "1" "Failed to start mpd"
}

startDaemon() {
  setupDaemon
  if [[ "$(checkDaemon)" -eq 1 ]]; then
    printf_exit "2" "1" "ERROR: $daemonName is already running."
  fi
  printf_green " *Starting $daemonName."
  echo "$myPid" >"$pidFile"
  log '*** '$(date +"%Y-%m-%d")": Starting up $daemonName."
  loop
}

stopDaemon() {
  if [[ "$(checkDaemon)" -eq 0 ]]; then
    printf_exit "1" "1" "ERROR: $daemonName is not running."
  fi
  echo "Stopping $daemonName"
  log '*** '$(date +"%Y-%m-%d")": $daemonName stopped."
  if [[ -n "$(cat $pidFile)" ]]; then
    __kill "$(cat "$pidFile")"
  fi
}

statusDaemon() {
  # Check if running
  if [[ "$(checkDaemon)" -eq 1 ]]; then
    printf_exit "2" "0" "$daemonName is running."
  else
    printf_exit "1" "1" "$daemonName is not running."
  fi
}

restartDaemon() {
  if [[ "$(checkDaemon)" -eq 0 ]]; then
    printf_red "$daemonName isn't running."
    startDaemon
  fi
  stopDaemon
  startDaemon &
  disown
}

checkDaemon() {
  # Check to see if the daemon is running.
  # This is a different function than statusDaemon
  # so that we can use it other functions.
  if [ -z "$oldPid" ]; then
    return 0
  elif [[ $(ps aux | grep "$oldPid" | grep -v grep) > /dev/null ]]; then
    if [ -f "$pidFile" ]; then
      if [[ $(cat "$pidFile") == "$oldPid" ]]; then
        # Daemon is running.
        echo 1
      else
        # Daemon isn't running.
        return 0
      fi
    fi
  else
    # Daemon not running.
    return 0
  fi
  return 1
}

loop() {
  # Just get the song title and artist.
  currentSong=$(__devnull2 __mpc)
  currTitleArtist="$(__devnull2 __mpc | head -n 1)"

  # Via mpc call and awk, get the status of mpd. For some reason, comparing the two as strings would not work. Converting their status to integers and comparing those, does.
  if [[ $(echo "$currentSong" | awk '/\[(paused|playing)\]/ {print $1}') == "[playing]" ]]; then
    curStatus=1
  elif [[ $(echo "$currentSong" | awk '/\[(paused|playing)\]/ {print $1}') == "[paused]" ]]; then
    curStatus=0
  fi

  curVol=$(echo "$currentSong" | grep -o -E "volume.+?%")

  # zzz
  sleep 1

  newSong=$(__devnull2 __mpc)
  newTitleArtist="$(__devnull2 __mpc | head -n 1)"

  if [[ $(echo "$newSong" | awk '/\[(paused|playing)\]/ {print $1}') == "[playing]" ]]; then
    newStatus=1
  elif [[ $(echo "$newSong" | awk '/\[(paused|playing)\]/ {print $1}') == "[paused]" ]]; then
    newStatus=0
  fi

  newVol=$(echo "$newSong" | grep -o -E "volume.+?%")

  # Get the path of the currently playing song as well as the cover.
  albumPath=$(getFile | sed -r 's/\/[^/]*$//')"/"
  albumPath="$(__devnull2 __mpc -f %file% | head -n 1)"

  notifyStatus
  notifySong
  notifyVolume

  loop
}

##################
#    ArgParse    #
##################

if [ -f "$pidFile" ]; then
  oldPid="$(cat "$pidFile")"
fi
checkDaemon
case "$1" in
"")
  startDaemon &
  disown
  ;;
start)
  startDaemon &
  disown
  ;;
stop)
  stopDaemon
  ;;
status)
  statusDaemon
  ;;
restart)
  restartDaemon
  ;;
*)
  printf_exit "Error: usage $0 { start | stop | restart | status }"
  ;;
esac

exit 0

# end
