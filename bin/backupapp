#!/usr/bin/env bash

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
APPNAME="backupapp"
USER="${SUDO_USER:-${USER}}"
HOME="${USER_HOME:-${HOME}}"

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
##@Version       : 020320211327-git
# @Author        : Jason Hempstead
# @Contact       : jason@casjaysdev.com
# @License       : WTFPL
# @ReadME        : backupapp --help
# @Copyright     : Copyright: (c) 2021 Jason Hempstead, CasjaysDev
# @Created       : Wednesday, Feb 03, 2021 13:27 EST
# @File          : backupapp
# @Description   : Backup files and folders
# @TODO          :
# @Other         :
# @Resource      :
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Import functions
CASJAYSDEVDIR="${CASJAYSDEVDIR:-/usr/local/share/CasjaysDev/scripts}"
SCRIPTSFUNCTDIR="${CASJAYSDEVDIR:-/usr/local/share/CasjaysDev/scripts}/functions"
SCRIPTSFUNCTFILE="${SCRIPTSAPPFUNCTFILE:-testing.bash}"
SCRIPTSFUNCTURL="${SCRIPTSAPPFUNCTURL:-https://github.com/dfmgr/installer/raw/master/functions}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
if [ -f "$PWD/$SCRIPTSFUNCTFILE" ]; then
  . "$PWD/$SCRIPTSFUNCTFILE"
elif [ -f "$SCRIPTSFUNCTDIR/$SCRIPTSFUNCTFILE" ]; then
  . "$SCRIPTSFUNCTDIR/$SCRIPTSFUNCTFILE"
fi
user_install
__options "$@"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# check for needed applications
__require_app tar
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Main application
declare filename count backupdir rmpre4vbackup _APPNAME _APPDIRS
[ "$1" = "--yes" ] && YN="Y" && shift 1
__mkd "$HOME/.config/backupapp" "$HOME/.config/backupapp/cron"
[ -f "$HOME/.config/backupapp/settings" ] && . "$HOME/.config/backupapp/settings"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__config() {
  local appname="${1:-settings}"
  printf_green "Generating the config file for ${1:-main}"
  echo -e '# Settings for backupapp - '${1:-main}'\nCONFIGNAME="'${1:-main}'"' >"$HOME/.config/backupapp/$appname"
  if [ -n "$1" ]; then
    _APPNAME="$1"
    echo _APPNAME="'$appname'" | tee -a "$HOME/.config/backupapp/$appname" &>/dev/null
    shift 1
  fi
  if [ -n "$1" ]; then
    _APPDIRS="$*"
    echo _APPDIRS="'$_APPDIRS'" | tee -a "$HOME/.config/backupapp/$appname" &>/dev/null
  fi
  shift
  echo 'LOG_DIR="'$HOME/.local/log/backups/apps'"
BACKUP_DIR="'$HOME/.local/backups/apps'"
NOTIFY_ENABLED="yes"
DATE_FORMAT="%Y-%m-%d-%H_%M-%S"
FILENAME_FORMAT="$(date +"$DATEFORMAT")"
LOGNAME_FORMAT="$(date +"$DATEFORMAT")"
LOGFILE_EXTENSION=".log"
KEEP_AMOUNT="5"
BICON_GOOD="[ 🆗 ]"
BICON_WARN="[ ⚠️ ]"
BICON_ERROR="[ ✖ }"
' | tee -a "$HOME/.config/backupapp/$appname" &>/dev/null
  __ln_sf "$HOME/.config/backupapp/$appname" "$HOME/.config/backupapp/cron/$appname"
  printf_green "File saved to: $HOME/.config/backupapp/$appname"
  printf_blue "You can create per app setting by running backupapp config Name Directories"
}

main() {
  local e err appname appdir
  local appname="${1:-$_APPNAME}" && shift 1
  local appdir="${*:-$_APPDIRS}" && shift
  local logdir="${LOG_DIR:-$HOME/.local/log/backups/apps}"
  local datefmt="%Y-%m-%d-%H-%M-%S"
  local curdate="$(date +"${DATE_FORMAT:-$datefmt}")"
  local filenameformate="${FILENAME_FORMAT:-$curdate}"
  local logfilenameformat="${LOGNAME_FORMAT:-$curdate}"
  local logfilenameextension="${LOGFILE_EXTENSION:-.log}"
  local backupdir="${BACKUP_DIR:-$HOME/.local/backups/apps}"
  local notifyEnabled="${NOTIFY_ENABLED:-yes}"
  local leaveCount="${KEEP_AMOUNT:-5}"
  local icon_good="${BICON_GOOD:-🆗}"
  local icon_warn="${BICON_WARN:-⚠️}"
  local icon_error="${BICON_ERROR:-✖}"
  local filename="$appname-$filenameformate.tar.gz"
  local logname="$appname-$logfilenameformat.$logfilenameextension"
  __backupcmd() { tar cfzv "$backupdir/$filename" $appdir >>"$logdir/$logname" 2>>"$logdir/$logname" || return 1; }
  [ "$notifyEnabled" = "yes" ] && notifications "Backupapp" "Initializing backup of $appname"
  execute "sleep 3" "Initializing"
  for e in $appdir; do [ -e "$e" ] || err="$e"; done
  if [ -n "$err" ]; then
    [ "$notifyEnabled" = "yes" ] && notifications "Backupapp" "Can't back up: $err doesn't exists"
    printf_error "Can't back up: $err doesn't exists"
    exit 1
  fi
  shift

  __mkd "$backupdir" "$logdir"
  printf_header " # Started on $(date +'%A, %B %d, %Y %H:%M:%S')" "# Backing up $appdir" >>"$logdir/$logname" >>"$logdir/$logname"
  execute "__backupcmd" "Backing up $appname to $backupdir"
  exitCode=$?
  printf_header " #Ended on $(date +'%A, %B %d, %Y %H:%M:%S')" >>"$logdir/$logname"
  printf_newline "\n\n" >>"$logdir/$logname"
  if [ "$exitCode" = 0 ]; then
    printf_green "$icon_good The backup has completed successfully and Saved to:"
    printf_green "$icon_good $backupdir/$filename"
    [ "$notifyEnabled" = "yes" ] && notifications "Backupapp" "Backup of $appname has completed"
  else
    printf_red "$icon_error The backup has failed to complete."
    printf_red "$icon_error More information can be found in the log file:"
    printf_exit "$icon_warn $logdir/$logname"
    [ "$notifyEnabled" = "yes" ] && notifications "Backupapp" "Backup of $appname has failed"
  fi
  logfileCount=$(ls $logdir/$appname*.$logfilenameextension 2>/dev/null | wc -l 2>/dev/null)
  logremoveoldbackups=$(ls $logdir/$appname*.$logfilenameextension 2>/dev/null)
  fileCount=$(ls $backupdir/$appname*.tar.gz 2>/dev/null | wc -l 2>/dev/null)
  removeoldbackups=$(ls $backupdir/$appname*.tar.gz 2>/dev/null)
  tailCount=$((fileCount - leaveCount))
  if [ "$fileCount" -gt "$leaveCount" ] && [ $leaveCount -ne 0 ]; then
    ls -t $removeoldbackups | tail -$tailCount 2>/dev/null | xargs rm -f
    ls -t $logremoveoldbackups | tail -$tailCount 2>/dev/null | xargs rm -f
  fi
  return $exitCode
}

__term() {
  while :; do
    local _APPDIRS _APPNAME cont
    clear
    printf_newline "\n\n\n\n"
    printf_head "Backup Menu"
    printf_custom "6" "Welcome to the backup menu: type quit to exit"
    printf_read_question_nt "2" "Enter backupname: " "120" "_APPNAME"
    if [ "$_APPNAME" = "quit" ]; then
      break
    fi
    printf_read_question_nt "2" "Enter directories:" "140" "_APPDIRS"
    printf_newline
    if [ -n "$_APPNAME" ] && [ -n "$_APPDIRS" ]; then
      main "$_APPNAME" "$_APPDIRS"
    else
      [ -n "$_APPNAME" ] || printf_pause "Needs an name"
      [ -n "$_APPDIRS" ] || printf_pause "Needs a directory"
    fi
    printf_newline
    printf_read_question_nt "6" "Would you like to keep this window open? [y/N]" "1" cont "-s"
    printf_answer_yes "$cont" && continue || break
    printf_counter "5" "3" "Re-loading menu in"
  done
  printf_newline "\n\n"
  exit $?
}
__local_cron_add() { __setupcrontab "${3:-0 0 * * *}" "backupapp --yes $1 $2 >/dev/null 2>&1"; }
__local_cron_del() { __removecrontab "backupapp --yes $1 $2"; }

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
case "$1" in
*cron)
  shift 1
  #cron case 2
  case "$1" in
  *all)
    shift 1
    if [ "$(__count_files "$HOME/.config/backupapp/cron/")" -ne 0 ]; then
      for cronjob in $(ls "$HOME/.config/backupapp/cron/"); do
        source "$HOME/.config/backupapp/cron/$cronjob"
        if [ -n "$_APPNAME" ] && [ -n "$_APPDIRS" ]; then
          echo "Backup up $cronjob"
          main "$_APPNAME" "$_APPDIRS" >/dev/null 2>&1
          exitCode=$?
          sleep 3
          if [ "$exitCode" = 0 ]; then echo "Backup up of $cronjob has completed"; else echo "Backup up of $cronjob has failed"; fi
        fi
        unset _APPNAME _APPDIRS
      done
    else
      printf_exit 0 1 "No files were found"
    fi
    ;;
  *list)
    shift 1
    if [ -z "$(crontab -l | grep -F "backupapp ")" ]; then
      printf_red "You don't have any jobs enabled"
    else
      printf_green "current cron jobs for backupapp"
      crontab -l | grep -F "backupapp " | printf_readline "4"
    fi
    exit
    ;;
  *add)
    shift 1
    if [ $# -gt 1 ]; then
      __local_cron_add "$1" "$2" "$3"
      #if [ "$(crontab -l | grep -q "$1 $2" 2>/dev/null)" ]; then
      printf_green "$1 $2 has been added to your cron jobs"
      #else
      #  printf_red "failed to add $1 $2"
      #fi
    else
      printf_custom "4" 'Usage: backupapp cron --add "Backupname" "BackupDir" "Frequency" | default nightly at midnight'
      printf_custom "4" 'Example: backupapp cron --add "Documents" "~/Documents" "0 0 * * *"'
    fi
    exit $?
    ;;
  *del)
    shift 1
    if [ $# -eq 2 ]; then
      __local_cron_del "$1" "$2"
      #if [ "$(crontab -l | grep -qv "$1 $2" 2>/dev/null)" ]; then
      printf_green "$1 $2 has been removed from your cron jobs"
      #else
      #  printf_red "failed to delete $1 $2"
      #fi
    else
      printf_help 'Usage: backupapp cron --del "Backupname" "BackupDir"'
    fi
    exit $?
    ;;
  *)
    printf_custom "4" 'Usage: backupapp cron --add "Backupname" "BackupDir"'
    printf_custom "4" 'Usage: backupapp cron --del "Backupname" "BackupDir"'
    exit
    ;;
  esac
  ;;
  # end cron
*term)
  shift 1
  __term
  ;;
*config)
  shift 1
  __config "$@"
  ;;
*)
  if [ -f "$HOME/.config/backupapp/${1}" ] && [ "$#" -lt 2 ]; then
    [ "$YN" = "Y" ] || printf_read_question_nt "6" "I found a settings file for $1: Should I use that?" "1" YN "-s"
    if printf_answer_yes "$YN"; then
      . "$HOME/.config/backupapp/${1}"
      if [ -n "$_APPNAME" ] && [ -n "$_APPDIRS" ]; then
        main "$_APPNAME" "$_APPDIRS"
      else
        printf_exit 1 1 "Could get the settings for _APPNAME and _APPDIRS"
      fi
    elif [ "$#" -gt 1 ]; then
      _APPNAME="$1" && shift 1
      _APPDIRS="$*" && shift
      main "$_APPNAME" "$_APPDIRS"
    else
      __help
    fi
  elif [ "$#" -gt 1 ]; then
    _APPNAME="$1" && shift 1
    _APPDIRS="$*" && shift
    main "$_APPNAME" "$_APPDIRS"
  else
    __help
  fi
  ;;
esac

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
exit $?
# end
